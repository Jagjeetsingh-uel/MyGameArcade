<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Chroma Shift</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg: #050010;
            --cyan: #00f3ff;
            --magenta: #ff0055;
            --grid: rgba(64, 0, 100, 0.3);
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
        
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background: var(--bg);
            font-family: 'Orbitron', sans-serif;
            color: white;
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* CRT SCANLINE EFFECT */
        .scanlines {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none; z-index: 5;
        }

        /* UI OVERLAY */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 20px;
        }

        .hud-top {
            display: flex; justify-content: space-between; align-items: flex-start;
            pointer-events: auto;
        }

        .score-box { text-align: left; }
        .score-label { font-size: 0.8rem; color: var(--cyan); opacity: 0.8; letter-spacing: 2px; }
        .score-val { 
            font-size: 3rem; font-weight: 900; line-height: 1;
            text-shadow: 0 0 10px var(--cyan);
        }

        /* Pause Button */
        .btn-icon {
            width: 44px; height: 44px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-size: 1.2rem; background: rgba(0,0,0,0.5);
            color: var(--cyan); cursor: pointer; pointer-events: auto;
        }

        /* MENUS */
        .menu-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 0, 16, 0.85);
            backdrop-filter: blur(10px);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 20; opacity: 0; pointer-events: none;
            transition: opacity 0.3s ease;
        }
        .menu-overlay.active { opacity: 1; pointer-events: auto; }

        .panel {
            border: 2px solid var(--cyan);
            box-shadow: 0 0 20px var(--cyan), inset 0 0 20px var(--cyan);
            background: rgba(0,0,0,0.8);
            padding: 40px; width: 85%; max-width: 400px;
            text-align: center; position: relative;
            clip-path: polygon(10% 0, 100% 0, 100% 90%, 90% 100%, 0 100%, 0 10%);
        }

        h1 {
            margin: 0 0 10px 0; font-size: 2.5rem;
            background: linear-gradient(90deg, var(--cyan), white, var(--magenta));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-transform: uppercase; font-style: italic;
        }

        p { color: #ccc; margin-bottom: 30px; font-size: 1rem; line-height: 1.5; }

        .btn-main {
            background: var(--cyan); color: #000; border: none;
            padding: 15px 30px; font-size: 1.2rem; font-weight: 900;
            font-family: 'Orbitron', sans-serif; text-transform: uppercase;
            cursor: pointer; clip-path: polygon(10% 0, 100% 0, 100% 80%, 90% 100%, 0 100%, 0 20%);
            transition: all 0.2s; width: 100%;
        }
        .btn-main:active { transform: scale(0.95); background: white; }

        .tutorial-box {
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(255,255,255,0.05);
            padding: 20px; margin-bottom: 20px; text-align: left;
        }
        
        .color-dot { display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-right: 5px; }
        .c-cyan { background: var(--cyan); box-shadow: 0 0 5px var(--cyan); }
        .c-mag { background: var(--magenta); box-shadow: 0 0 5px var(--magenta); }

        /* FEEDBACK OVERLAYS */
        #flash-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 8; opacity: 0;
            transition: opacity 0.1s;
        }

        /* TAP HINT */
        .tap-hint {
            position: absolute; bottom: 10%; width: 100%; text-align: center;
            font-size: 1.2rem; color: white; opacity: 0.5;
            animation: blink 2s infinite; pointer-events: none;
        }
        @keyframes blink { 0%,100% {opacity:0.3} 50% {opacity:0.8} }

    </style>
</head>
<body>

    <!-- BACKGROUND CANVAS -->
    <canvas id="gameCanvas"></canvas>
    <div class="scanlines"></div>
    <div id="flash-overlay"></div>

    <!-- UI LAYER -->
    <div id="ui-layer">
        <div class="hud-top">
            <div class="score-box">
                <div class="score-label">SYNC RATE</div>
                <div class="score-val" id="scoreVal">0</div>
            </div>
            <div class="btn-icon" id="pauseBtn" style="display:none">||</div>
        </div>
        <div class="tap-hint" id="tapHint">TAP TO SHIFT</div>
    </div>

    <!-- START MENU -->
    <div id="startMenu" class="menu-overlay active">
        <div class="panel">
            <h1>CHROMA<br>SHIFT</h1>
            <div class="tutorial-box">
                <p style="margin:5px 0"><span class="color-dot c-cyan"></span> MATCH <b>CYAN</b> walls</p>
                <p style="margin:5px 0"><span class="color-dot c-mag"></span> MATCH <b>MAGENTA</b> walls</p>
                <p style="margin:15px 0 5px 0; font-size:0.9rem; color:#fff">TAP ANYWHERE TO SWITCH</p>
            </div>
            <button class="btn-main" id="startBtn">JACK IN</button>
        </div>
    </div>

    <!-- GAME OVER -->
    <div id="gameOverMenu" class="menu-overlay">
        <div class="panel" style="border-color:var(--magenta); box-shadow: 0 0 20px var(--magenta);">
            <h1 style="color:var(--magenta); -webkit-text-fill-color: var(--magenta);">SYSTEM<br>FAILURE</h1>
            <p>DATA COLLECTED: <span id="finalScore" style="color:white; font-weight:bold">0</span></p>
            <button class="btn-main" id="retryBtn" style="background:var(--magenta)">REBOOT</button>
        </div>
    </div>

<script>
    /**
     * CHROMA SHIFT
     * A fast-paced color matching runner.
     */

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // UI Refs
    const ui = {
        score: document.getElementById('scoreVal'),
        startMenu: document.getElementById('startMenu'),
        gameOverMenu: document.getElementById('gameOverMenu'),
        finalScore: document.getElementById('finalScore'),
        pauseBtn: document.getElementById('pauseBtn'),
        tapHint: document.getElementById('tapHint'),
        flash: document.getElementById('flash-overlay')
    };

    // Colors
    const COLORS = {
        cyan: '#00f3ff',
        magenta: '#ff0055',
        bg: '#050010'
    };

    // Game Config
    const CFG = {
        playerSpeed: 0, // Player is stationary in Y, world moves
        baseSpeed: 6,
        speedInc: 0.005,
        spawnRate: 60, // Frames between walls
        wallHeight: 30
    };

    // State
    let state = {
        running: false,
        paused: false,
        score: 0,
        highScore: parseInt(localStorage.getItem('chromaHigh') || 0),
        gameSpeed: CFG.baseSpeed,
        frames: 0,
        polarity: 'cyan' // 'cyan' or 'magenta'
    };

    // Entities
    let player = {
        x: 0, y: 0,
        radius: 20,
        trail: []
    };

    let walls = [];
    let particles = [];
    let gridOffset = 0;

    // --- INIT ---
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        player.x = canvas.width / 2;
        player.y = canvas.height - 150;
    }
    window.addEventListener('resize', resize);

    function resetGame() {
        state.running = true;
        state.paused = false;
        state.score = 0;
        state.gameSpeed = CFG.baseSpeed;
        state.frames = 0;
        state.polarity = 'cyan';

        walls = [];
        particles = [];
        
        ui.score.innerText = '0';
        ui.startMenu.classList.remove('active');
        ui.gameOverMenu.classList.remove('active');
        ui.pauseBtn.style.display = 'flex';
        ui.pauseBtn.innerText = '||';
        ui.tapHint.style.display = 'block';

        loop();
    }

    // --- INPUT ---
    function togglePolarity(e) {
        if(e) e.preventDefault();
        if (!state.running || state.paused) return;

        state.polarity = state.polarity === 'cyan' ? 'magenta' : 'cyan';
        
        // Visual feedback
        createBurst(player.x, player.y, state.polarity === 'cyan' ? COLORS.cyan : COLORS.magenta, 5);
        ui.tapHint.style.display = 'none'; // Hide hint on first tap
    }

    canvas.addEventListener('mousedown', togglePolarity);
    canvas.addEventListener('touchstart', togglePolarity, {passive: false});

    document.getElementById('startBtn').addEventListener('click', resetGame);
    document.getElementById('retryBtn').addEventListener('click', resetGame);
    
    ui.pauseBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if(!state.running) return;
        state.paused = !state.paused;
        ui.pauseBtn.innerText = state.paused ? 'â–¶' : '||';
        if(!state.paused) loop();
        else draw(); // Draw paused state
    });

    // --- GAME LOGIC ---
    function update() {
        state.frames++;
        state.gameSpeed += CFG.speedInc;

        // Spawn Walls
        // Adaptive difficulty: Spawn rate gets faster as speed increases
        let currentRate = Math.max(20, Math.floor(CFG.spawnRate - (state.score / 10)));
        
        if (state.frames % currentRate === 0) {
            spawnWall();
        }

        // Update Walls
        for (let i = walls.length - 1; i >= 0; i--) {
            let w = walls[i];
            w.y += state.gameSpeed;

            // Collision Check
            // Wall is a horizontal line. Check if player circle intersects it.
            // Simple bounding box check for Y, but infinite X
            if (w.y > player.y - player.radius && w.y < player.y + player.radius) {
                if (!w.passed) {
                    if (w.type === state.polarity) {
                        // SUCCESS
                        w.passed = true;
                        state.score++;
                        ui.score.innerText = state.score;
                        createBurst(player.x, w.y, w.type === 'cyan' ? COLORS.cyan : COLORS.magenta, 15);
                        screenFlash(w.type === 'cyan' ? 'rgba(0,243,255,0.2)' : 'rgba(255,0,85,0.2)');
                    } else {
                        // FAIL
                        gameOver();
                    }
                }
            }

            // Remove off-screen
            if (w.y > canvas.height + 50) {
                walls.splice(i, 1);
            }
        }

        // Update Particles
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.05;
            if (p.life <= 0) particles.splice(i, 1);
        }

        // Background Grid Animation
        gridOffset += state.gameSpeed;
        if(gridOffset > 40) gridOffset = 0;

        // Player Trail
        player.trail.push({x: player.x, y: player.y, color: state.polarity});
        if(player.trail.length > 10) player.trail.shift();
    }

    function spawnWall() {
        // Randomize type, but ensure not too many of same color in a row? 
        // Random is actually fine for reaction.
        let type = Math.random() > 0.5 ? 'cyan' : 'magenta';
        walls.push({
            y: -50,
            type: type,
            passed: false
        });
    }

    function createBurst(x, y, color, count) {
        for(let i=0; i<count; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                life: 1,
                color: color
            });
        }
    }

    function screenFlash(color) {
        ui.flash.style.backgroundColor = color;
        ui.flash.style.opacity = 1;
        setTimeout(() => { ui.flash.style.opacity = 0; }, 50);
    }

    // --- RENDER ---
    function draw() {
        // Clear
        ctx.fillStyle = COLORS.bg;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 1. Draw Retro Grid (Pseudo-3D)
        ctx.strokeStyle = 'var(--grid)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        // Vertical perspective lines
        let centerX = canvas.width / 2;
        for(let i = -5; i <= 5; i++) {
            // simple perspective faking
            let x1 = centerX + (i * 50);
            let x2 = centerX + (i * 300); // Fanned out at bottom
            ctx.moveTo(x1, 0);
            ctx.lineTo(x2, canvas.height);
        }

        // Horizontal moving lines
        for(let y = gridOffset; y < canvas.height; y += 40) {
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
        }
        ctx.stroke();

        // 2. Draw Player Trail
        for(let i=0; i<player.trail.length; i++) {
            let t = player.trail[i];
            let size = (i / player.trail.length) * player.radius * 2;
            ctx.fillStyle = t.color === 'cyan' ? COLORS.cyan : COLORS.magenta;
            ctx.globalAlpha = 0.3;
            ctx.beginPath();
            ctx.arc(t.x, t.y, size/2, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;

        // 3. Draw Player
        let pColor = state.polarity === 'cyan' ? COLORS.cyan : COLORS.magenta;
        
        // Outer Glow
        ctx.shadowBlur = 20;
        ctx.shadowColor = pColor;
        ctx.fillStyle = pColor;
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.radius, 0, Math.PI*2);
        ctx.fill();
        
        // Inner Core (White)
        ctx.fillStyle = '#fff';
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.radius * 0.6, 0, Math.PI*2);
        ctx.fill();

        // 4. Draw Walls
        walls.forEach(w => {
            let wColor = w.type === 'cyan' ? COLORS.cyan : COLORS.magenta;
            ctx.shadowBlur = 10;
            ctx.shadowColor = wColor;
            ctx.fillStyle = wColor;
            
            // Draw bar across screen with a gap in middle? 
            // No, design says "Pass Through". So it's a solid bar that is semi-transparent?
            // Or a laser beam.
            
            let height = 20;
            // Make it look like a laser beam
            ctx.fillRect(0, w.y - height/2, canvas.width, height);
            
            // Bright core line
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, w.y - 2, canvas.width, 4);
            
            ctx.shadowBlur = 0;
        });

        // 5. Draw Particles
        particles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 3, 0, Math.PI*2);
            ctx.fill();
        });
        ctx.globalAlpha = 1;
        
        // Paused Overlay
        if(state.paused) {
            ctx.fillStyle = "rgba(0,0,0,0.6)";
            ctx.fillRect(0,0,canvas.width, canvas.height);
            ctx.fillStyle = COLORS.cyan;
            ctx.font = "30px 'Orbitron'";
            ctx.textAlign = "center";
            ctx.fillText("SYSTEM PAUSED", canvas.width/2, canvas.height/2);
        }
    }

    function loop() {
        if (!state.running || state.paused) return;
        update();
        draw();
        requestAnimationFrame(loop);
    }

    function gameOver() {
        state.running = false;
        ui.finalScore.innerText = state.score;
        ui.gameOverMenu.classList.add('active');
        ui.pauseBtn.style.display = 'none';
        createBurst(player.x, player.y, '#fff', 50);
        draw();
    }

    // Start
    resize();
    
    // Initial render for background
    draw();

</script>
</body>
</html>