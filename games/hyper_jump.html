<!DOCTYPE html>
<html lang="en">
<head>
    <script defer src="/MyGameArcade/analytics.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hyper Jump - Tower Climb</title>
    <meta name="description" content="Hyper Jump: Climb the endless tower by jumping on platforms. Screen scrolls down as you ascend. Desktop: arrows + space. Mobile: tilt + tap. High score challenge.">
    <meta name="keywords" content="HTML5 game, tower climb, endless jumper, platformer, mobile game, browser game, hyper jump">
    <meta name="author" content="Jagjeet Singh">
    <meta name="robots" content="index,follow">
    <link rel="canonical" href="https://jagjeetsingh-uel.github.io/MyGameArcade/games/hyper_jump.html">
    <!-- Open Graph / Social -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Hyper Jump - Endless Tower Climb">
    <meta property="og:description" content="Jump higher and higher in this retro-style tower climber. Avoid the rising floor!">
    <meta property="og:url" content="https://jagjeetsingh-uel.github.io/MyGameArcade/games/hyper_jump.html">
    <meta property="og:image" content="https://jagjeetsingh-uel.github.io/MyGameArcade/assets/cover.png">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Hyper Jump - Tower Climb">
    <meta name="twitter:description" content="Endless jumping platformer with scrolling screen.">
    <meta name="twitter:image" content="https://jagjeetsingh-uel.github.io/MyGameArcade/assets/cover.png">
    <meta name="theme-color" content="#050510">
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700;900&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-color: #0c0a18; /* Deep Space Blue */
            --accent: #FFD700; /* Gold (Player) */
            --secondary: #4ecdc4; /* Teal (Platforms) */
            --safe-zone: #ff8c00; /* Orange (Safe Platforms) */
            --danger: #ff0055; /* Cyber Red */
            --ui-bg: rgba(255, 255, 255, 0.05);
            --font-main: 'Rajdhani', sans-serif;
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
        
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background: var(--bg-color);
            font-family: var(--font-main);
            color: white;
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* --- UI LAYER --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column;
            padding: 20px;
            z-index: 10;
        }

        .hud {
            display: flex; justify-content: space-between; align-items: flex-start;
            pointer-events: auto;
        }

        .score-container { text-align: left; }

        .score-val {
            font-size: 3.5rem; font-weight: 900; line-height: 1;
            color: white;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .label { font-size: 1rem; text-transform: uppercase; letter-spacing: 2px; opacity: 0.7; }

        .btn-pause {
            width: 50px; height: 50px;
            border-radius: 12px;
            background: var(--ui-bg);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            display: flex; justify-content: center; align-items: center;
            font-size: 1.5rem; cursor: pointer; color: var(--accent);
            transition: all 0.2s;
        }
        .btn-pause:active { transform: scale(0.9); background: rgba(255,255,255,0.15); }
        .btn-pause.hidden { display: none; }

        /* --- MENUS --- */
        .menu-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 16, 0.9);
            backdrop-filter: blur(15px);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 20;
            transition: opacity 0.3s ease;
            opacity: 0; pointer-events: none;
        }
        .menu-overlay.active { opacity: 1; pointer-events: auto; }

        .card {
            background: linear-gradient(145deg, rgba(255,255,255,0.05) 0%, rgba(255,255,255,0.01) 100%);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 40px; border-radius: 20px;
            text-align: center; width: 85%; max-width: 400px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            position: relative;
            overflow: hidden;
        }
        
        .card::before {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 4px;
            background: linear-gradient(90deg, var(--secondary), var(--accent));
        }

        h1 {
            margin: 0; font-size: 3rem; text-transform: uppercase;
            font-style: italic; font-weight: 900;
            color: white; letter-spacing: -1px;
            margin-bottom: 10px;
        }

        p { color: #aaa; margin-bottom: 30px; font-size: 1.1rem; line-height: 1.6; }

        /* Device-Specific Instructions */
        .tutorial-box { display: none; }
        .tutorial-box.active {
            display: block;
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            border-left: 3px solid var(--accent);
            text-align: left;
        }
        .tutorial-box p { margin: 10px 0; color: #fff; font-size: 1.1rem; }
        .highlight { color: var(--accent); font-weight: bold; }
        .key {
            background: #fff; color: #000; padding: 2px 8px; border-radius: 4px;
            font-family: monospace; font-weight: bold;
        }

        .btn-primary {
            background: var(--accent); color: #000;
            border: none; width: 100%; padding: 18px;
            font-family: var(--font-main); font-weight: 900; font-size: 1.4rem;
            text-transform: uppercase; letter-spacing: 1px;
            border-radius: 8px; cursor: pointer;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.4); /* Gold shadow */
            transition: transform 0.1s, box-shadow 0.2s;
        }
        .btn-primary:active { transform: scale(0.96); box-shadow: 0 0 10px rgba(255, 215, 0, 0.2); }
        
        #pause-text {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem; color: #fff; font-weight: 900;
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
            display: none;
        }
        #pause-text.active { display: block; }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud">
            <div class="score-container">
                <div class="score-val" id="scoreVal">0</div>
                <div class="label" id="highScoreVal">HI: 0</div>
            </div>
            <div class="btn-pause hidden" id="pauseBtn">||</div>
        </div>
        <div id="pause-text">PAUSED</div>
    </div>

    <!-- START MENU -->
    <div id="startMenu" class="menu-overlay active">
        <div class="card">
            <h1>Hyper<br><span style="color:var(--accent)">Jump</span></h1>
            
            <!-- Desktop Instructions -->
            <div class="tutorial-box" id="tutorial-desktop">
                <p>1. <span class="key">←</span> / <span class="key">→</span> to Move</p>
                <p>2. <span class="key">SPACE</span> to Jump</p>
                <p>3. Don't fall in the <span class="highlight">Glitch!</span></p>
            </div>
            
            <!-- Mobile Instructions -->
            <div class="tutorial-box" id="tutorial-mobile">
                <p>1. <span class="highlight">TILT</span> device to Move</p>
                <p>2. <span class="highlight">TAP</span> screen to Jump</p>
                <p>3. Don't fall in the <span class="highlight">Glitch!</span></p>
            </div>

            <button class="btn-primary" id="startBtn">START</button>
        </div>
    </div>

    <!-- GAME OVER MENU -->
    <div id="gameOverMenu" class="menu-overlay">
        <div class="card">
            <h1 style="color:var(--danger)">GAME OVER</h1>
            <p>Score: <span id="finalScore" style="color:white; font-weight:bold">0</span></p>
            <p style="margin-top:-20px;">High Score: <span id="finalHighScore" style="color:white; font-weight:bold">0</span></p>
            <button class="btn-primary" id="retryBtn">RETRY</button>
        </div>
    </div>

<script>
    /**
     * HYPER JUMP v2
     * - New Colors (Gold/Teal)
     * - More Platforms (Closer Gap)
     * - Fixed Tilt Controls
     * - Fixed Platform Generation Bug
     * - Added 500m Safe Zones
     * - Fixed Physics/Sliding Bug
     * - Fixed Retry Menu Bug
     * - Fixed Jump Spam Bug
     */

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // UI
    const ui = {
        score: document.getElementById('scoreVal'),
        highScore: document.getElementById('highScoreVal'),
        startMenu: document.getElementById('startMenu'),
        gameOverMenu: document.getElementById('gameOverMenu'),
        finalScore: document.getElementById('finalScore'),
        finalHighScore: document.getElementById('finalHighScore'),
        pauseBtn: document.getElementById('pauseBtn'),
        pauseText: document.getElementById('pause-text'),
        startBtn: document.getElementById('startBtn'),
        retryBtn: document.getElementById('retryBtn')
    };

    // CONFIG
    const COLORS = {
        accent: getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#FFD700',
        secondary: getComputedStyle(document.documentElement).getPropertyValue('--secondary').trim() || '#4ecdc4',
        safeZone: getComputedStyle(document.documentElement).getPropertyValue('--safe-zone').trim() || '#ff8c00',
        danger: getComputedStyle(document.documentElement).getPropertyValue('--danger').trim() || '#ff0055',
        bg: getComputedStyle(document.documentElement).getPropertyValue('--bg-color').trim() || '#0c0a18'
    };
    
    const CFG = {
        gravity: 0.5,
        friction: 0.8,
        moveSpeed: 6,
        jumpForce: 15,
        platformHeight: 15,
        minPlatformWidth: 80,
        maxPlatformWidth: 150,
        platformGapY: 80, // <-- More platforms
        baseFloorSpeed: 0.2, 
        cameraLerp: 0.08,
        playerSize: 25
    };

    // STATE
    let state = {
        running: false,
        paused: false,
        gameStarted: false, 
        score: 0,
        highScore: 0,
        cameraY: 0,
        floorY: 0, 
        isMobile: false,
        nextSafeZone: 500,
        spawnSafeZone: false 
    };

    // ENTITIES
    let player = {
        x: 0, y: 0,
        vx: 0, vy: 0,
        width: CFG.playerSize,
        height: CFG.playerSize,
        onGround: false,
        anim: {
            scaleX: 1,
            scaleY: 1,
            eyeSize: 4,
            eyeBlinkTimer: 0
        }
    };
    let platforms = [];
    let particles = [];
    let keys = { left: false, right: false, jump: false };

    // --- INIT ---
    function init() {
        resize();
        detectDevice();
        loadHighScore();
        ui.startBtn.addEventListener('click', requestStartGame);
        ui.retryBtn.addEventListener('click', startGame);
        ui.pauseBtn.addEventListener('click', togglePause);
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        draw(); 
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);

    function detectDevice() {
        state.isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        if (state.isMobile) {
            document.getElementById('tutorial-mobile').classList.add('active');
        } else {
            document.getElementById('tutorial-desktop').classList.add('active');
        }
    }

    function loadHighScore() {
        state.highScore = parseInt(sessionStorage.getItem('hyperJumpHigh') || 0);
        ui.highScore.innerText = `HI: ${state.highScore}`;
    }

    function saveHighScore() {
        if (state.score > state.highScore) {
            state.highScore = state.score;
            sessionStorage.setItem('hyperJumpHigh', state.highScore);
        }
    }

    function requestStartGame() {
        if (state.isMobile) {
            if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                DeviceMotionEvent.requestPermission()
                    .then(response => {
                        if (response == 'granted') {
                            window.addEventListener('devicemotion', handleMotion);
                        }
                        startGame();
                    })
                    .catch(() => startGame()); 
            } else {
                window.addEventListener('devicemotion', handleMotion);
                startGame();
            }
        } else {
            startGame();
        }
    }

    function startGame() {
        state.running = true;
        state.paused = false;
        state.gameStarted = false; 
        state.score = 0;
        state.cameraY = 0;
        state.floorY = canvas.height + 100;
        state.nextSafeZone = 500; 
        state.spawnSafeZone = false; 
        
        player.x = canvas.width / 2 - CFG.playerSize / 2;
        player.y = canvas.height - 100;
        player.vx = 0;
        player.vy = 0;
        player.onGround = false;

        platforms = [];
        particles = [];
        
        // Create foundation
        platforms.push({
            x: 0, 
            y: canvas.height - 50,
            width: canvas.width, 
            height: CFG.platformHeight,
            isSafeZone: true // Treat start as safe zone
        });
        
        // Create initial screen of platforms
        generatePlatforms(canvas.height, 0);

        ui.score.innerText = "0";
        ui.highScore.innerText = `HI: ${state.highScore}`; // Update high score display
        ui.startMenu.classList.remove('active');
        ui.gameOverMenu.classList.remove('active'); // <-- FIX: Hide game over menu
        ui.pauseBtn.classList.remove('hidden');
        ui.pauseText.classList.remove('active');

        loop();
    }

    function gameOver() {
        state.running = false;
        saveHighScore();
        ui.finalScore.innerText = state.score;
        ui.finalHighScore.innerText = state.highScore;
        ui.gameOverMenu.classList.add('active');
        ui.pauseBtn.classList.add('hidden');
    }

    function togglePause() {
        if (!state.running) return;
        state.paused = !state.paused;
        ui.pauseBtn.innerText = state.paused ? "▶" : "||";
        ui.pauseText.classList.toggle('active', state.paused);
        if (!state.paused) {
            loop(); // Resume loop
        }
    }

    // --- CONTROLS ---
    function handleKeyDown(e) {
        if (e.code === 'ArrowLeft') keys.left = true;
        if (e.code === 'ArrowRight') keys.right = true;
        if (e.code === 'Space') keys.jump = true;
        if (e.code === 'KeyP') togglePause();
    }
    function handleKeyUp(e) {
        if (e.code === 'ArrowLeft') keys.left = false;
        if (e.code === 'ArrowRight') keys.right = false;
        if (e.code === 'Space') keys.jump = false;
    }
    function handleTouchStart(e) {
        e.preventDefault();
        if (!state.running) return;
        keys.jump = true; 
    }
    function handleMotion(e) {
        // --- MOBILE TILT SENSOR CONTROLS ----------------------------------
        // This handler is attached when motion permission is granted on mobile.
        // We read rotationRate.gamma (device tilt around Y axis). Typical values:
        //   gamma > 0  : device top tilts RIGHT
        //   gamma < 0  : device top tilts LEFT
        // The user requested INVERSION of previous behavior. Previously: vx = tilt * 0.4
        // Now we invert so tilting RIGHT (positive gamma) moves character LEFT and vice‑versa.
        // Adjust the multiplier (0.4) to tune horizontal sensitivity.
        if (e.rotationRate && typeof e.rotationRate.gamma === 'number') {
            const tilt = e.rotationRate.gamma;
            player.vx = -tilt * 0.4; // INVERTED MAPPING
        }
    }

    // --- GAME LOGIC ---
    function generatePlatforms(fromY, toY) {
        let y = fromY - CFG.platformGapY;

        if (state.spawnSafeZone) {
            platforms.push({
                x: 0, y: y,
                width: canvas.width,
                height: CFG.platformHeight,
                isSafeZone: true 
            });
            y -= CFG.platformGapY; 
            state.spawnSafeZone = false; 
        }

        while (y > toY) {
            let width = CFG.minPlatformWidth + Math.random() * (CFG.maxPlatformWidth - CFG.minPlatformWidth);
            let x = Math.random() * (canvas.width - width);
            platforms.push({ x, y, width, height: CFG.platformHeight, isSafeZone: false });
            y -= CFG.platformGapY;
        }
    }

    function createParticles(x, y, color) {
        for(let i=0; i<5; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 5,
                vy: (Math.random() - 0.5) * 5 - 2,
                life: 30,
                color: color
            });
        }
    }
    
    // --- UPDATE ---
    function update() {
        // 1. Handle Jump Input
        if (keys.jump && player.onGround) {
            if (!state.gameStarted) {
                state.gameStarted = true;
                state.floorY = canvas.height; 
            }
            player.vy = -CFG.jumpForce;
            player.onGround = false;
            keys.jump = false; // <-- FIX: Consume the jump input immediately
            
            player.anim.scaleX = 1.3;
            player.anim.scaleY = 0.7;
            createParticles(player.x + player.width/2, player.y + player.height, '#fff');
        }

        // 2. Player Physics (Vertical)
        player.vy += CFG.gravity;
        player.y += player.vy;
        
        player.onGround = false; 

        // 3. Platform Collision
        for (let p of platforms) {
            let prevBottom = (player.y - player.vy) + player.height;
            let currBottom = player.y + player.height;
            
            if (player.vy >= 0 && 
                prevBottom <= p.y && 
                currBottom >= p.y &&
                player.x + player.width > p.x && 
                player.x < p.x + p.width) 
            {
                player.y = p.y - player.height;
                player.vy = 0;
                player.onGround = true; 
                
                // *** PHYSICS FIX ***
                // Apply friction *only* if not actively moving
                if (!keys.left && !keys.right && !state.isMobile) {
                     player.vx *= CFG.friction;
                }
                
                player.anim.scaleX = 1.2;
                player.anim.scaleY = 0.8;
                break; 
            }
        }

        // 4. Handle Horizontal Input
        if (!state.isMobile) {
            if (keys.left) {
                player.vx = -CFG.moveSpeed;
            } else if (keys.right) {
                player.vx = CFG.moveSpeed;
            } else if (player.onGround) { // Only apply ground friction if no keys pressed
                player.vx *= CFG.friction;
            }
        } else {
             // Mobile friction (applied constantly, tilt overcomes it)
             player.vx *= (CFG.friction * 0.98); // Slightly less friction for tilt
        }
        
        // 5. Apply Horizontal Physics
        player.x += player.vx; 

        // 6. Screen Bounds (Left/Right)
        if (player.x < 0) { player.x = 0; player.vx = 0; }
        if (player.x + player.width > canvas.width) { player.x = canvas.width - player.width; player.vx = 0; }

        // --- All vertical logic is now gated by state.gameStarted ---
        // FIX: Floor only moves after player has climbed 70 points
        if (state.gameStarted && state.score > 70) {
            // 7. Update Score
            let heightScore = Math.floor(Math.max(0, -player.y + canvas.height - 100));
            if (heightScore > state.score) {
                state.score = heightScore;
                
                // NEW: Check for safe zone
                if (state.score >= state.nextSafeZone) {
                    state.spawnSafeZone = true;
                    state.nextSafeZone += 500;
                }
            }
            ui.score.innerText = state.score;

            // 8. Move Glitch Floor
            // Floor speed increases by 0.1 every 1000 score units, clamped to max 2.0
            const floorIncrements = Math.floor(state.score / 800) * 0.1;
            const floorSpeed = Math.min(2, CFG.baseFloorSpeed + floorIncrements);
            state.floorY -= floorSpeed; 
            
            // 9. Update Camera
            let targetCamY = player.y - canvas.height * 0.6; 
            let floorCamY = state.floorY - canvas.height; 
            
            let desiredCamY = Math.min(targetCamY, floorCamY + 50); 
            state.cameraY += (desiredCamY - state.cameraY) * CFG.cameraLerp;
        } else if (state.gameStarted) {
            // Player has jumped, but not high enough for floor to move
            let heightScore = Math.floor(Math.max(0, -player.y + canvas.height - 100));
            if (heightScore > state.score) {
                state.score = heightScore;
            }
            ui.score.innerText = state.score;

            let targetCamY = player.y - canvas.height * 0.6;
            if (targetCamY < state.cameraY) { 
                 state.cameraY += (targetCamY - state.cameraY) * CFG.cameraLerp;
            }
        }
        
        // 10. Generate platforms (This check is now independent of score)
        let topOfScreen = state.cameraY;
        // FIX: Generate two screens worth to prevent running out
        if (platforms.length > 0 && topOfScreen < (platforms[platforms.length - 1].y + CFG.platformGapY)) {
            generatePlatforms(platforms[platforms.length - 1].y, topOfScreen - canvas.height * 2);
        }

        // 11. Cleanup old platforms
        if (platforms.length > 0 && platforms[0].y > state.cameraY + canvas.height + 100) {
            platforms.shift();
        }
        
        // 12. Check Game Over
        let deathLine = state.gameStarted ? state.floorY : canvas.height + 50;
        if (player.y > deathLine) {
            gameOver();
            return;
        }

        // 13. Update Animations
        player.anim.scaleX += (1 - player.anim.scaleX) * 0.2;
        player.anim.scaleY += (1 - player.anim.scaleY) * 0.2;
        player.anim.eyeBlinkTimer--;
        if(player.anim.eyeBlinkTimer <= 0) {
            player.anim.eyeSize = (player.anim.eyeSize === 4) ? 1 : 4;
            player.anim.eyeBlinkTimer = (player.anim.eyeSize === 1) ? 10 : (100 + Math.random() * 200);
        }

        // 14. Update Particles
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
            if (p.life <= 0) particles.splice(i, 1);
        }
    }

    // --- DRAW ---
    function draw() {
        ctx.fillStyle = COLORS.bg;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        ctx.translate(0, -state.cameraY); 

        // Draw Glitch Floor
        let grad = ctx.createLinearGradient(0, state.floorY, 0, state.floorY + 200);
        grad.addColorStop(0, 'rgba(255, 0, 85, 0.8)');
        grad.addColorStop(1, 'rgba(255, 0, 85, 0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0, state.floorY, canvas.width, canvas.height * 2); 
        
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, state.floorY);
        for(let i=0; i<canvas.width; i+=10) ctx.lineTo(i + (Math.random()-0.5)*10, state.floorY + (Math.random()-0.5)*4);
        ctx.stroke();

        // Draw Platforms
        platforms.forEach(p => {
            if (p.y > state.cameraY + canvas.height || p.y + p.height < state.cameraY - 50) {
                return;
            }
            
            // NEW: Style for Safe Zone
            if (p.isSafeZone) {
                ctx.fillStyle = COLORS.safeZone;
                ctx.fillRect(p.x, p.y, p.width, p.height);
                ctx.fillStyle = '#fff';
                ctx.fillRect(p.x, p.y, p.width, 3);
            } else {
                ctx.fillStyle = '#222';
                ctx.fillRect(p.x, p.y, p.width, p.height);
                ctx.fillStyle = COLORS.secondary; 
                ctx.fillRect(p.x, p.y, p.width, 3); 
            }
        });

        // Draw Player (Cube)
        ctx.save();
        let pCenterX = player.x + player.width / 2;
        let pCenterY = player.y + player.height / 2;
        let pDrawWidth = player.width * player.anim.scaleX;
        let pDrawHeight = player.height * player.anim.scaleY;
        
        ctx.translate(pCenterX, pCenterY);
        
        ctx.fillStyle = COLORS.accent; 
        ctx.shadowColor = COLORS.accent; 
        ctx.shadowBlur = 15;
        ctx.fillRect(-pDrawWidth / 2, -pDrawHeight / 2, pDrawWidth, pDrawHeight);
        ctx.shadowBlur = 0;
        
        ctx.fillStyle = '#000';
        let eyeOffX = 5;
        if(player.vx > 1) eyeOffX = 7;
        if(player.vx < -1) eyeOffX = 3;
        
        ctx.fillRect(-eyeOffX - 2, -3, 4, player.anim.eyeSize); // Left
        ctx.fillRect(eyeOffX - 2, -3, 4, player.anim.eyeSize); // Right
        
        ctx.restore(); 

        // Draw Particles
        particles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life / 30;
            ctx.fillRect(p.x, p.y, 3, 3);
            ctx.globalAlpha = 1;
        });

        ctx.restore(); 
    }

    // --- GAME LOOP ---
    function loop() {
        if (!state.running) {
            return; 
        }
        if (state.paused) {
            draw(); 
            return; 
        }

        update();
        draw();
        requestAnimationFrame(loop);
    }

    // Start
    init();

</script>
</body>
</html>