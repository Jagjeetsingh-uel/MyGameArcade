<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Orbit</title>
    <!-- SEO -->
    <meta name="description" content="Neon Orbit: Circle the core and time jumps to clear red spikes. Mid‑air second tap for double jump.">
    <meta name="keywords" content="neon orbit, circular runner, double jump, timing game, HTML5 arcade">
    <meta name="author" content="Jagjeet Singh">
    <meta name="robots" content="index,follow">
    <link rel="canonical" href="https://jagjeetsingh-uel.github.io/MyGameArcade/games/neon_orbit.html">
    <meta property="og:type" content="game">
    <meta property="og:title" content="Neon Orbit – Neon Arcade">
    <meta property="og:description" content="Orbit core. Jump spikes. Master the double jump.">
    <meta property="og:url" content="https://jagjeetsingh-uel.github.io/MyGameArcade/games/neon_orbit.html">
    <meta property="og:image" content="https://jagjeetsingh-uel.github.io/MyGameArcade/assets/neon_orbit.png">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Neon Orbit – Neon Arcade">
    <meta name="twitter:description" content="Circular runner with double jump timing.">
    <meta name="twitter:image" content="https://jagjeetsingh-uel.github.io/MyGameArcade/assets/neon_orbit.png">
    <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@400;700;900&display=swap" rel="stylesheet">
    <!-- Site Analytics -->
    <script defer src="/MyGameArcade/analytics.js"></script>
    
    <style>
        :root {
            --bg-gradient: radial-gradient(circle at center, #1a2a6c, #b21f1f, #fdbb2d);
            --bg-color: #0f0c29;
            --accent: #00d2ff;
            --danger: #ff0055;
            --font-main: 'Exo 2', sans-serif;
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
        
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background: var(--bg-color);
            font-family: var(--font-main);
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* UI OVERLAY */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 20px;
        }

        .top-bar {
            display: flex; justify-content: space-between; align-items: flex-start;
            pointer-events: auto;
        }

        .score-box {
            text-align: center;
            color: white;
            text-shadow: 0 0 10px var(--accent);
        }
        .score-val { font-size: 4rem; font-weight: 900; line-height: 1; }
        .score-label { font-size: 0.8rem; opacity: 0.8; letter-spacing: 2px; margin-top: 5px; }

        .btn-icon {
            width: 48px; height: 48px;
            border-radius: 12px;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            display: flex; justify-content: center; align-items: center;
            color: white; font-size: 1.2rem; cursor: pointer;
        }
        .btn-icon:active { transform: scale(0.95); background: rgba(255,255,255,0.2); }

        /* MENU SCREENS */
        .menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 12, 41, 0.85);
            backdrop-filter: blur(10px);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 10; pointer-events: auto;
            transition: opacity 0.3s;
        }
        .hidden { opacity: 0; pointer-events: none; }

        .card {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 40px; border-radius: 24px;
            text-align: center; width: 90%; max-width: 400px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
        }

        h1 {
            margin: 0 0 10px 0; font-size: 2.5rem; font-weight: 900;
            background: linear-gradient(to right, #fff, var(--accent));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        p { color: #aaa; margin-bottom: 30px; line-height: 1.6; }

        .btn-action {
            background: var(--accent); color: #000;
            border: none; padding: 16px 32px;
            border-radius: 50px; font-size: 1.2rem; font-weight: 900;
            text-transform: uppercase; letter-spacing: 1px; cursor: pointer;
            box-shadow: 0 0 20px rgba(0, 210, 255, 0.4);
            transition: transform 0.1s; width: 100%;
        }
        .btn-action:active { transform: scale(0.98); }

        #tutorial {
            text-align: center; color: rgba(255,255,255,0.5);
            font-size: 0.9rem; margin-bottom: 30px;
            animation: pulse 2s infinite;
        }
        @keyframes pulse { 0%,100%{opacity:0.5} 50%{opacity:1} }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="top-bar">
            <div class="btn-icon" id="pauseBtn">⏸</div>
            <div class="score-box">
                <div class="score-val" id="scoreVal">0</div>
                <div class="score-label" id="highScoreVal">BEST: 0</div>
            </div>
            <div class="btn-icon" style="opacity:0"></div>
        </div>
        <div id="tutorial">Tap to JUMP • Mid-air tap to DOUBLE JUMP</div>
    </div>

    <!-- START SCREEN -->
    <div id="startScreen" class="menu">
        <div class="card">
            <h1>NEON ORBIT</h1>
            <p>Run along the core.<br>Jump the red spikes.</p>
            <button class="btn-action" id="startBtn">LAUNCH</button>
        </div>
    </div>

    <!-- GAME OVER SCREEN -->
    <div id="gameOverScreen" class="menu hidden">
        <div class="card">
            <h1 style="color: var(--danger); -webkit-text-fill-color: initial; background:none;">CRASH</h1>
            <p>Orbit Failed</p>
            <div class="score-val" id="finalScore" style="margin-bottom: 20px">0</div>
            <button class="btn-action" id="retryBtn">RETRY</button>
        </div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const ui = {
        score: document.getElementById('scoreVal'),
        highScore: document.getElementById('highScoreVal'),
        finalScore: document.getElementById('finalScore'),
        startScreen: document.getElementById('startScreen'),
        gameOverScreen: document.getElementById('gameOverScreen'),
        pauseBtn: document.getElementById('pauseBtn'),
        tutorial: document.getElementById('tutorial')
    };

    let game = {
        running: false,
        paused: false,
        score: 0,
        highScore: parseInt(localStorage.getItem('orbitHigh') || 0),
        speed: 0,
        rotation: 0,
        radius: 100,
        cx: 0, cy: 0,
        frames: 0
    };

    let player = {
        angle: Math.PI / 2, // Fixed at bottom (90 deg)
        height: 0,
        velocity: 0,
        jumps: 0
    };

    let obstacles = [];
    let particles = [];
    let stars = [];

    const GRAVITY = 0.6;
    const JUMP_FORCE = 12;
    const BASE_SPEED = 0.04;

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        game.cx = canvas.width / 2;
        game.cy = canvas.height / 2;
        game.radius = Math.min(canvas.width, canvas.height) * 0.25;
        initStars();
    }

    function initStars() {
        stars = [];
        for(let i=0; i<60; i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 2,
                alpha: Math.random()
            });
        }
    }

    function resetGame() {
        game.score = 0;
        game.speed = BASE_SPEED;
        game.rotation = 0;
        game.frames = 0;
        game.running = true;
        game.paused = false;
        
        player.height = 0;
        player.velocity = 0;
        player.jumps = 0;

        obstacles = [];
        particles = [];

        ui.score.innerText = "0";
        ui.highScore.innerText = `BEST: ${game.highScore}`;
        ui.startScreen.classList.add('hidden');
        ui.gameOverScreen.classList.add('hidden');
        ui.tutorial.style.display = 'block';
        
        // BUG FIX: Spawn first obstacle with 0 offset
        // This puts it at Math.PI * 1.5 (Top of screen)
        // Player is at Math.PI * 0.5 (Bottom of screen)
        // Safe distance!
        spawnObstacle(0); 
    }

    function spawnObstacle(offsetAngle) {
        // Spawn based on current rotation so it appears "ahead" at the top
        const spawnAngle = -game.rotation + (Math.PI * 1.5) + offsetAngle;
        
        obstacles.push({
            angle: spawnAngle,
            width: 0.25 + Math.random() * 0.1, // Slightly wider for better visibility
            height: 25 + Math.random() * 15,
            type: Math.random() > 0.8 ? 'double' : 'single',
            passed: false,
            color: '#ff0055'
        });
    }

    function createExplosion(x, y, color) {
        for(let i=0; i<15; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 8,
                vy: (Math.random() - 0.5) * 8,
                life: 1.0,
                color: color
            });
        }
    }

    function update() {
        if (!game.running || game.paused) return;

        game.frames++;
        game.speed += 0.000005; // Slower acceleration so it's playable
        game.rotation += game.speed;

        // Player Physics
        player.height += player.velocity;
        player.velocity -= GRAVITY;
        
        if (player.height <= 0) {
            player.height = 0;
            player.velocity = 0;
            player.jumps = 0;
        }

        // Obstacle Spawning Logic
        // Frequency increases as speed increases
        let spawnRate = Math.floor(120 / (game.speed * 20)); 
        if (spawnRate < 60) spawnRate = 60; // Cap max spawn rate

        if (game.frames % spawnRate === 0) {
             // 70% chance to spawn an obstacle
             if(Math.random() > 0.3) spawnObstacle(0);
        }
        
        // Update Obstacles & Collision
        for (let i = obstacles.length - 1; i >= 0; i--) {
            let obs = obstacles[i];
            
            // Calculate visible angle (0 to 2PI)
            let visibleAngle = (obs.angle + game.rotation) % (Math.PI * 2);
            if (visibleAngle < 0) visibleAngle += Math.PI * 2;

            // Collision Detection
            // Player is at PI/2 (1.57)
            let dist = Math.abs(visibleAngle - Math.PI/2);
            if (dist > Math.PI) dist = (Math.PI * 2) - dist; // Wrap around

            // Hitbox: slightly smaller than visual width to be forgiving
            if (dist < obs.width / 2.5) { 
                if (player.height < obs.height) {
                    gameOver();
                }
            }

            // Scoring
            // If we just passed the player angle (PI/2)
            // We use a small window (PI/2 to PI/2 + 0.2) to trigger score once
            // We check "pure" visible angle before wrap logic for scoring direction
            if (!obs.passed) {
                 // Check if it moved past PI/2 (Bottom) moving clockwise
                 // It spawns at 3PI/2 (Top) and rotates to PI/2
                 // So we check if angle is slightly GREATER than PI/2
                 if (visibleAngle > Math.PI/2 && visibleAngle < Math.PI) {
                     obs.passed = true;
                     game.score++;
                     ui.score.innerText = game.score;
                 }
            }

            // Cleanup "old" obstacles (approx 2 full rotations)
            if (obs.angle + game.rotation > Math.PI * 8) {
                obstacles.splice(i, 1);
            }
        }
        
        // Particles
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx; p.y += p.vy;
            p.life -= 0.05;
            if (p.life <= 0) particles.splice(i, 1);
        }
    }

    function draw() {
        // BG
        ctx.fillStyle = '#0f0c29';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Stars
        ctx.fillStyle = '#fff';
        stars.forEach(s => {
            ctx.globalAlpha = s.alpha;
            ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI*2); ctx.fill();
        });
        ctx.globalAlpha = 1;

        // Core Planet
        ctx.save();
        ctx.translate(game.cx, game.cy);
        
        ctx.shadowBlur = 30; ctx.shadowColor = '#00d2ff';
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.arc(0, 0, game.radius, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#00d2ff'; ctx.lineWidth = 4; ctx.stroke();
        ctx.shadowBlur = 0;

        // Obstacles (Rotated)
        ctx.save();
        ctx.rotate(game.rotation);
        
        obstacles.forEach(obs => {
            ctx.save();
            ctx.rotate(obs.angle);
            ctx.fillStyle = obs.color;
            ctx.shadowBlur = 15; ctx.shadowColor = obs.color;
            
            ctx.beginPath();
            ctx.moveTo(-5, game.radius);
            ctx.lineTo(5, game.radius);
            ctx.lineTo(0, game.radius + obs.height);
            ctx.fill();
            ctx.restore();
        });
        ctx.restore();

        // Player (Static at bottom)
        ctx.rotate(Math.PI / 2); 
        
        const pY = game.radius + player.height + 10;
        
        ctx.shadowBlur = 20; ctx.shadowColor = '#00d2ff';
        ctx.fillStyle = '#00d2ff';
        ctx.beginPath(); ctx.arc(0, pY, 10, 0, Math.PI*2); ctx.fill();
        
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(0, pY, 5, 0, Math.PI*2); ctx.fill();
        
        ctx.restore(); // End Planet context

        // Particles
        ctx.save(); // Particles are in screen coordinates, not planet coordinates
        particles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life;
            ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill();
        });
        ctx.restore();
        ctx.globalAlpha = 1;
        
        requestAnimationFrame(loop);
    }

    function loop() {
        update();
        draw();
    }

    function jump() {
        if (!game.running || game.paused) return;
        
        if (player.jumps < 2) {
            player.velocity = JUMP_FORCE;
            player.jumps++;
            ui.tutorial.style.display = 'none';
            
            // Particle effect
            // Need to calculate Screen Coordinates for explosion
            // Player is always at Bottom Center
            const px = game.cx; 
            const py = game.cy + game.radius + player.height;
            createExplosion(px, py, '#fff');
        }
    }

    function gameOver() {
        game.running = false;
        if (game.score > game.highScore) {
            game.highScore = game.score;
            localStorage.setItem('orbitHigh', game.highScore);
        }
        ui.finalScore.innerText = game.score;
        ui.gameOverScreen.classList.remove('hidden');
        
        // Explosion at player position
        createExplosion(game.cx, game.cy + game.radius + player.height, '#ff0055');
    }

    function togglePause() {
        if (!game.running) return;
        game.paused = !game.paused;
        ui.pauseBtn.innerText = game.paused ? "▶" : "⏸";
    }

    // INPUTS
    window.addEventListener('resize', resize);
    
    canvas.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        jump();
    });
    
    window.addEventListener('keydown', (e) => {
        if(e.code === 'Space' || e.code === 'ArrowUp') jump();
        if(e.code === 'KeyP' || e.code === 'Escape') togglePause();
    });

    document.getElementById('startBtn').addEventListener('click', resetGame);
    document.getElementById('retryBtn').addEventListener('click', resetGame);
    ui.pauseBtn.addEventListener('click', (e) => {
        e.stopPropagation(); togglePause();
    });

    // Init
    resize();
    ui.highScore.innerText = `BEST: ${game.highScore}`;
    loop(); 

</script>
</body>
</html>